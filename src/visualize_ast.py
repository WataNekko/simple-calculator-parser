import argparse
import json
import os
from turtle import color

from matplotlib.pyplot import text
from numpy import half


# cli arguments parsing
parser = argparse.ArgumentParser(
    description="Visualize the AST generated by the calculator parser"
)

parser.add_argument("filename", metavar="PATH", help="the path to the AST JSON file")

args = parser.parse_args()

# draw AST
try:
    import matplotlib.pyplot as plt
    from matplotlib.animation import FuncAnimation
    from matplotlib.textpath import TextPath
    from matplotlib.patches import PathPatch
    from matplotlib.transforms import Affine2D
except ModuleNotFoundError:
    raise SystemExit(
        "This script requires matplotlib to run.\n"
        "Run the 'pip install matplotlib' command to install it."
    )


# set up mpl
fig, ax = plt.subplots()
fig.canvas.manager.set_window_title("AST Visualization")
plt.xkcd()
plt.tick_params(left=False, bottom=False, labelleft=False, labelbottom=False)

init = True


def on_resize(_):
    global init
    if init:
        init = False
    else:
        adjust_limits()


fig.canvas.mpl_connect("resize_event", on_resize)


# watch file for changes
def poll_change(on_change):
    """Poll the input file's modified time to check for changes."""
    try:
        mtime = os.stat(args.filename).st_mtime
        if mtime != poll_change.cached_mtime:
            poll_change.cached_mtime = mtime
            on_change()
    except FileNotFoundError:
        return


## init mtime to None so that on_change is always called on the first poll
poll_change.cached_mtime = None


# spacing
text_height = 14
tree_lvl_spacing = 20
tree_lvl_height = text_height + tree_lvl_spacing  # add spacing between each level
xpad = 15
ypad = 2
lim_pad = 5


# draw AST
def update_frame():
    try:
        with open(args.filename) as f:
            ast = json.load(f)
            draw_ast(ast)
    except (FileNotFoundError, json.decoder.JSONDecodeError, KeyError, TypeError):
        draw_ast(None)


def draw_ast(ast):
    plt.cla()

    if ast is None:
        return

    global xmax, ymin
    _, xmax, ymin = draw_node(ast["root"], 0, 0)

    plt.title(f'"{ast["expr"]}"')
    adjust_limits()
    plt.tight_layout()


def adjust_limits():
    global xmax, ymin

    w_fig, h_fig = fig.get_size_inches()
    r_fig = w_fig / h_fig

    w_ast, h_ast = xmax, text_height - ymin
    r_ast = w_ast / h_ast

    if r_fig > r_ast:
        plt.ylim([ymin - lim_pad, text_height])
        xcenter = xmax / 2
        half_xlim_width = 0.5 * (h_ast + lim_pad) * r_fig
        plt.xlim([xcenter - half_xlim_width, xcenter + half_xlim_width])
    else:
        plt.xlim([-lim_pad, xmax + lim_pad])
        ycenter = (text_height + ymin) / 2
        half_ylim_width = 0.5 * (w_ast + 2 * lim_pad) / r_fig
        plt.ylim([ycenter - half_ylim_width, ycenter + half_ylim_width])


def draw_node(node, x, y):
    """Returns (xtop, xmax, ymin)
    xtop: x of top node
    xmax: xmax of the bounding box of the drawn node and its children
    ymin: ymin of the bounding box of the drawn node and its children"""
    type_ = node["type"]

    if type_ == "number":
        tp = TextPath((x, y), node["value"])
        ax.add_patch(PathPatch(tp, color="black"))

        bb = tp.get_extents()
        return (bb.x0 + bb.x1) / 2, bb.xmax, bb.ymin

    elif type_ == "ans":
        tp = TextPath((x, y), "ans")
        ax.add_patch(PathPatch(tp, color="black"))

        bb = tp.get_extents()
        return (bb.x0 + bb.x1) / 2, bb.xmax, bb.ymin

    elif type_ in ("+", "-", "*", "/"):
        children_height = y - tree_lvl_height

        # operand nodes
        l_xtop, l_xmax, l_ymin = draw_node(node["left"], x, children_height)
        r_xtop, r_xmax, r_ymin = draw_node(
            node["right"], l_xmax + xpad, children_height
        )

        # operator node
        xcenter = l_xmax + xpad / 2
        tp = TextPath((xcenter, y), type_)
        bb = tp.get_extents()
        tf = Affine2D().translate((bb.xmin - bb.xmax) / 2, 0)
        ax.add_patch(PathPatch(tp.transformed(tf), color="black"))

        # edges
        y_plot = [y - ypad, y - tree_lvl_spacing]
        plt.plot([xcenter, l_xtop], y_plot, color="teal")
        plt.plot([xcenter, r_xtop], y_plot, color="teal")

        return xcenter, r_xmax, min(l_ymin, r_ymin)

    elif type_ in ("u+", "u-"):
        # operand node
        xtop, xmax, ymin = draw_node(node["operand"], x, y - tree_lvl_height)

        # operator node
        xcenter = (x + xmax) / 2
        tp = TextPath((xcenter, y), type_[1])
        bb = tp.get_extents()
        tf = Affine2D().translate((bb.xmin - bb.xmax) / 2, 0)
        ax.add_patch(PathPatch(tp.transformed(tf), color="black"))

        # edge
        plt.plot([xcenter, xtop], [y - ypad, y - tree_lvl_spacing], color="teal")

        return xcenter, xmax, ymin
    else:
        raise TypeError(type_)


# mpl animation
def animate(_):
    poll_change(update_frame)


ani = FuncAnimation(fig, animate, interval=40)
plt.show()
